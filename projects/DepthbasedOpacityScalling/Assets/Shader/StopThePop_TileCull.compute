// Improved tile culling using x_hat with groupshared constants and coherent loops.
// Thread group: 64 threads (1D) -> portable baseline.

#pragma kernel CS_TileCull

cbuffer _TileCullParams
{
    uint    _TileSize;      // e.g., 16
    float   _CullEpsilon;   // e.g., 1e-4
    float4  _ScreenSize;    // (W,H,1/W,1/H)
    float4x4 _View;
    float4x4 _Proj;
}

StructuredBuffer<float4> _SplatPosScale;  // xyz=mu_w, w=scale proxy
StructuredBuffer<uint>   _SplatIndices;   // global candidate list
StructuredBuffer<uint2>  _TileRanges;     // per-tile (start,count)
RWStructuredBuffer<uint> _KeepFlags;      // 1=keep, 0=cull

float2 worldToPixel_fast(float3 mu_w, out float viewZ)
{
    float4 v = mul(_View, float4(mu_w,1));
    viewZ = v.z;
    float4 c = mul(_Proj, v);
    float invW = rcp(max(c.w, 1e-6));
    float2 ndc = c.xy * invW;
    return mad(ndc, 0.5, 0.5) * _ScreenSize.xy;
}

// sigma ≈ scale * f / -z  (isotropic approx)
float sigma_screen(float scaleProxy, float viewZ, float fx)
{
    float s = scaleProxy * fx * rcp(max(-viewZ, 1e-3));
    return clamp(s, 0.5, 2048.0);
}

float peak_value_in_tile(float2 m_pix, float sigma, uint2 tileXY, uint tileSize)
{
    float2 tileMin = float2(tileXY) * tileSize;
    float2 tileMax = tileMin + tileSize;
    float2 xhat = clamp(m_pix, tileMin, tileMax);
    float2 d = (xhat - m_pix) / max(sigma, 1e-3);
    float d2 = dot(d, d);
    return exp(-0.5 * d2);
}

[numthreads(64,1,1)]
void CS_TileCull(uint3 dtid : SV_DispatchThreadID,
                 uint3 gtid : SV_GroupThreadID,
                 uint  gidx : SV_GroupIndex)
{
    uint tile = dtid.x;

    // groupshared: 타일 공통 상수 한 번만 계산
    groupshared float s_fx;
    groupshared uint  s_tileX, s_tileY, s_tileSize;
    if (gidx == 0)
    {
        float proj00 = _Proj[0][0];
        s_fx = _ScreenSize.x * 0.5 * rcp(max(proj00, 1e-6)); // f ≈ W/(2*proj00)

        uint tilesX = (uint)ceil(_ScreenSize.x / _TileSize);
        s_tileX = tile % tilesX;
        s_tileY = tile / tilesX;
        s_tileSize = _TileSize;
    }
    GroupMemoryBarrierWithGroupSync();

    uint2 range = _TileRanges[tile];
    uint start = range.x;
    uint count = range.y;
    if (count == 0) return;

    // stride by group size: 분기 적고 동적 카운트에도 안전
    for (uint i = gidx; i < count; i += 64)
    {
        uint idx   = start + i;
        uint splat = _SplatIndices[idx];

        float viewZ;
        float2 m_pix = worldToPixel_fast(_SplatPosScale[splat].xyz, viewZ);
        float sigma  = sigma_screen(_SplatPosScale[splat].w, viewZ, s_fx);

        float peak = peak_value_in_tile(m_pix, sigma, uint2(s_tileX, s_tileY), s_tileSize);
        _KeepFlags[idx] = (peak >= _CullEpsilon) ? 1u : 0u;
    }
}
