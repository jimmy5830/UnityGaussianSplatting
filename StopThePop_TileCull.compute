// StopThePop_TileCull.compute
// Precise tile culling using maximum-contribution point x_hat within a tile.
// Diagonal screen-space Gaussian approximation for robustness and speed.
// Integrates with GaussianSplatRenderer StopThePop path.
//
// Kernels:
//  - CS_TileCull: for each tile, iterate its candidate splats and write keep flags (0/1)
//                 based on peak contribution within the tile rectangle.

#pragma kernel CS_TileCull

// ========================= 입력 =========================
// 입력: 타일별 후보 인덱스(_TileRanges, _SplatIndices),
//       스플랫 위치/스케일(_SplatPosScale), 카메라 행렬/스크린 크기
cbuffer _TileCullParams
{
    uint    _TileSize;            // e.g., 16
    float   _CullEpsilon;         // e.g., 1e-4  (threshold on exp(-0.5*d2))
    float4  _ScreenSize;          // (W, H, 1/W, 1/H)
    float4x4 _View;
    float4x4 _Proj;
}

StructuredBuffer<float4> _SplatPosScale;  // xyz = mu_w, w = scale proxy (radius/sigma)
StructuredBuffer<uint>   _SplatIndices;   // global candidate list (post coarse bin/sort)
StructuredBuffer<uint2>  _TileRanges;     // per-tile (start, count) into _SplatIndices
// =======================================================

// ========================= 출력 =========================
// 출력: 타일 내 후보 각 항목에 대해 keep(1) 또는 cull(0)
RWStructuredBuffer<uint> _KeepFlags;      // same length as _SplatIndices
// =======================================================


// ========================= 아이디어 =========================
// 아이디어 요약:
// 1) 스플랫 중심 m를 스크린 픽셀 좌표로 투영
// 2) viewZ를 이용해 화면 공간 sigma_screen 추정
// 3) 타일 사각형에 대해 m를 clamp해 x_hat 계산
// 4) d^2 ≈ ||(x_hat − m)/sigma_screen||^2 로 근사
// 5) exp(-0.5 * d^2) >= epsilon 이면 keep
// ===========================================================

float2 worldToPixel(float3 mu_w, out float viewZ)
{
    float4 v = mul(_View, float4(mu_w,1));
    float4 c = mul(_Proj, v);
    viewZ = v.z;
    float2 ndc = c.xy / max(c.w, 1e-6);
    float2 pix = (ndc * 0.5 + 0.5) * _ScreenSize.xy; // 1) m in pixel space
    return pix;
}

// Simple screen-space sigma from world scale proxy and view depth.
// Assumes symmetric footprint; robust enough for culling decisions.
float sigma_screen(float scaleProxy, float viewZ)
{
    // Projected meters-to-pixels scale ≈ f / -z; fold into sigma ~ scaleProxy * f / -z
    // Use fx ~= 1/_Proj[0][0] mapping; in clip: proj[0][0] = 2f/W, so f ≈ W/(2*proj00)
    float proj00 = _Proj[0][0];
    float fx = (_ScreenSize.x) / max(2.0 * proj00, 1e-6);
    float s = scaleProxy * fx / max(-viewZ, 1e-3);   // 2) estimate sigma_screen
    // Clamp to avoid zero / exploding
    return clamp(s, 0.5, 2048.0);
}

// 각 스크린 중심 m을 타일 사각형으로 clamp 해서 x-hat을 구하고, mahalanobis 거리로 근삿값 계산
// Using diagonal covariance: A = diag(1/sx^2, 1/sy^2). With sx=sy=sigma_screen.
float peak_value_in_tile(float2 m_pix, float sigma, uint2 tileXY) // 스크린 중심 m
{
    float2 tileMin = float2(tileXY) * _TileSize;
    float2 tileMax = tileMin + _TileSize;
    // 3) Closest point x_hat to m_pix within axis-aligned rectangle
    float2 xhat = clamp(m_pix, tileMin, tileMax);
    // 4) d^2 approximation in screen space with diagonal covariance
    float2 d = (xhat - m_pix) / max(sigma, 1e-3);
    float d2 = dot(d, d); // (dx/s)^2 + (dy/s)^2
    // 5) Gaussian peak value at x_hat (unnormalized, relative): exp(-0.5 * d^2)
    return exp(-0.5 * d2);
}

[numthreads(64,1,1)]
void CS_TileCull(uint3 id : SV_DispatchThreadID)
{
    uint tile = id.x;
    uint2 range = _TileRanges[tile];
    uint start = range.x;
    uint count = range.y;
    if (count == 0) return;

    // Compute tile coords (integer) from tile index
    uint tilesX = (uint)ceil(_ScreenSize.x / _TileSize);
    uint tileX = tile % tilesX;
    uint tileY = tile / tilesX;
    uint2 tileXY = uint2(tileX, tileY);

    // Stride loop: one thread processes multiple entries
    for (uint i = id.y; i < count; i += 1) { // id.y fixed 0 in this layout
        uint idx = start + i;
        uint splat = _SplatIndices[idx];

        float viewZ;
        float2 m_pix = worldToPixel(_SplatPosScale[splat].xyz, viewZ);   // 입력 사용 1)
        float sigma = sigma_screen(_SplatPosScale[splat].w, viewZ);      // 입력 사용 2)

        // 아이디어 3) 4) 5) 수행
        float peak = peak_value_in_tile(m_pix, sigma, tileXY);

        // 출력 작성
        _KeepFlags[idx] = (peak >= _CullEpsilon) ? 1u : 0u;
    }
}
